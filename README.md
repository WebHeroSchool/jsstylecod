# JavaScript Best Practice Guide
## Содержание ##
1. [Глобальные переменные](#глобальные_переменные)
2. [Размещение функций](#размещение_функций)
3. [Declarations on Top](#declarations)
4. [Строгое сравнение](#строгое_сравнение)
5. [Именование](#именование)
6. [Для создания объекта используйте фигурные скобки.](#фигурные_скобки)
7. [Использовать значения параметров по умолчанию](#параметры_по_умолчанию)
8. [Остерегайтесь автоматического преобразования типов](#автоматическое_преобразование_типов)
9. [Используйте тернарные операторы](#тернарные_операторы)
10. [ Избегайте однобуквенных имен переменных](#однобуквенность)
***


### <a name="глобальные_переменные">1. Глобальные переменные</a> ###
Минимизируйте использование глобальных переменных. Одной из проблем, связанных с использованием глобальных переменных является то, что они могут быть перезаписаны другими сценариями.
Этот совет относится к работе со всеми типами данных, объектами и функциями.
Вместо этого используйте локальные переменные и замыкания.
Объявляйте все переменные с помощью **const** или **let**. По умолчанию используется const, за исключением случаев, кгда нужно переназначить переменную. Не используйте **var**.
```
//bad

let a = 100;   
  
function doSomething() {
  // тело функции
}
  
console.log(a); // 100 


// good
   
   function doSomething() {
     let a = 100;
     console.log(a);
   }
   doSomething();//100
```
***

### <a name="размещение_функций">2. Размещение функций </a> ###
Если вы пишете несколько вспомогательных функций, то предпочтительнее использовать следующую структуру:
сначала пишем код, использующий функции, а затем объявляем функции.
```
let elem = createElement();
setHandler(elem);
walkAround();

// --- вспомогательные функции ---
function createElement() {
  ...
}

function setHandler(elem) {
  ...
}

function walkAround() {
  ...
}
```
При чтении кода мы сначала хотим знать, что он делает. Если сначала идёт код, то это тут же становится понятно. И тогда, может быть, нам вообще не нужно будет читать функции, особенно если их имена хорошо подобраны.
***
### <a name="declarations"> 3. Declarations on Top. Объявления "вверху" </a> ###
Данная практика считается хорошей, поскольку:
+ код станет более читабельным;
+ вы будете знать, где искать локальные переменные;
+ вам будет проще избежать проблем с непредвиденными глобальными переменными;
+ уменьшится вероятность повторных объявлений переменных.
```
// Объявить в самом начале
var firstName, lastName, price, discount, fullPrice;

// Далее присвоить значения объявленным переменным
firstName = "John";
lastName = "Doe";

price = 19.90;
discount = 0.10;

fullPrice = price * 100 / discount;
```
***
###  <a name="строгое_сравнение"> 4. Строгое сравнение</a> ###
Для сравнения в JavaScript используйте оператор ===(!==) вместо ==(!=). Оператор нестрогого сравнения всегда преобразует (в соответствующие типы) перед сравнением. Использование сравнения с преобразованием типов может привести к непредвиденным проблемам, связанным с особенностями конвертации разных типов. Например, Объекты String имеют тип Object, а не String.
```
// bad
0 == "";        // true
1 == "1";       // true
1 == true;      // true

// good
0 === "";       // false
1 === "1";      // false
1 === true;     // false
```
***
### <a name="именование"> 5. Именование </a> ###
Имя переменной – существительное.

Имя функции – глагол (или начинается с глагола).

Для имён используется английский язык (не транслит!) и CamelCase. Имя может состоять из букв, цифр, символов $ и _, не должно начинаться с цифры.
Имя должно быть осмысленным, чтобы сразу иметь возможность понимать, для какого действия оно предназначено.
```
getUserName() {
  //тело функции
};

const userName;
```
Имена констант используют CONSTANT_CASE: все буквы прописные, слова разделяются символом подчеркивания.
Если переменная точно не должна меняться, это можно обозначить, написав ее имя только заглавными буквами. Это делает неизменность константы очевидной, где бы в коде она не использовалась.
```
const NUMBER = 5;
```
***
### <a name="фигурные_скобки"> 6. Создание новых объектов и массивов.</a> ###
Не создавайте массивы через конструктор new Array. Конструкторы массивов подвержены ошибкам. Правильнее будет создавать массивы, используя квадратные скобки:
```
// bad
let arr = new Array(a, b, c);

// good
let arr = [a, b, c];
```
Не создавайте объекты через конструктор new Object.
```
// bad
const item = new Object();

// good
const item = {};
```
***
### <a name="параметры_по_умолчанию"> 7. Использовать значения параметров по умолчанию </a> ###
Если функция вызвана без аргумента, недостающий аргумент принимает значение undefined. Такие значения могут сломать код, поэтому хорошей практикой является присвоение аргументам дефолтных значений.
```
function (а, b = 1) {
 // тело функции
}
```
***
### <a name="автоматическое_преобразование_типов"> 8. Остерегайтесь автоматического преобразования типов </a> ###
Имейте ввиду , что цифры случайно могут быть преобразованы в строки или NaN (не число).
JavaScript является слабо типизированным. Переменная может содержать различные типы данных, а переменная может изменить его тип данных:
```
let x = "Hello";     // typeof x is a string
x = 5;               // changes typeof x to a number
```
При выполнении математических операций, JavaScript может преобразовывать числа в строки.
Пример:
```
let  x = 5 + 7;       // x.valueOf() is 12,  typeof x is a number
let  x = 5 + "7";     // x.valueOf() is 57,  typeof x is a string
let  x = "5" + 7;     // x.valueOf() is 57,  typeof x is a string
let  x = 5 - 7;       // x.valueOf() is -2,  typeof x is a number
let  x = 5 - "7";     // x.valueOf() is -2,  typeof x is a number
let  x = "5" - 7;     // x.valueOf() is -2,  typeof x is a number
let  x = 5 - "x";     // x.valueOf() is NaN, typeof x is a number
```
***
### <a name="тернарные_операторы"> 9. Используйте тернарные операторы </a> ###
Это сокращает код. Например:
```
// вместо этого
if (val) {
  return foo();
} else {
  return bar();
}

// можно записать так
return val ? foo() : bar();
```
***
### <a name="однобуквенность"> 10. Избегайте однобуквенных имен переменных </a> ###
В долгосрочной перспективе от слишком коротких имен больше хлопот, чем экономии на нажатиях клавиш.
Имена должны быть краткими и описательными. Переменная, инициализированная глобально, может в конечном итоге использоваться через сотню строк. Если она обозначается одной буквой, легко забыть, что это за переменная.
```
const date = new Date()
```
гораздо лучше, чем
```
const d = new Date();
```
Однобуквенные имена можно использовать в маленьких функциях или в качестве индекса в цикле.
***
